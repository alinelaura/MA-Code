---
title: "Masterthesis script"
author: "Aline Laura Metzler"
date: "5/26/2022"
output:
  pdf_document:
    latex_engine: xelatex
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



```{r message=FALSE, warning=FALSE}
library(ggplot2)
library(tidyverse)
library(dplyr)
library(forcats)
library(ggplot2)
library(forcats)
```

# Create a custom theme for the plots

```{r}
# define a theme function
theme_masterthesis <- function(base_size=12, base_family="Times New Roman") {
      library(grid)
      library(ggthemes)
      library(extrafont)
      (theme_foundation(base_size=base_size, base_family=base_family) + 
          theme(plot.title = element_text(face = "bold",
                                         size = rel(1.2)),
               plot.subtitle = element_text(face = "italic",
                                         size = rel(1)),
               text = element_text(),
               panel.background = element_rect(colour = NA),
               plot.background = element_rect(colour = NA),
               panel.border = element_rect(colour = NA),
               axis.title = element_text(face = "bold",size = rel(1)),
               axis.title.y = element_text(angle=90,vjust =2),
               axis.title.x = element_text(vjust = -0.2),
               axis.text = element_text(), 
               axis.line = element_line(colour="black"),
               axis.ticks = element_line(),
               panel.grid.major = element_line(colour="#f0f0f0"),
               panel.grid.minor = element_blank(),
               legend.key = element_rect(colour = NA),
               legend.position = "bottom",
               legend.direction = "horizontal",
               legend.key.size= unit(0.2, "cm"),
               legend.margin = unit(0, "cm"),
               legend.title = element_text(face="italic"),
               plot.margin=unit(c(10,5,5,5),"mm"),
               strip.background=element_rect(colour="#f0f0f0",fill="#f0f0f0"),
               strip.text = element_text(face="bold")
          ))
      
}

# TODO: Define color scheme
# Define Color scales for Charts
scale_fill_masterthesis <- function(...){
      library(scales)
      discrete_scale("fill","Publication",
                     manual_pal(values = c("#386cb0","#fdb462","#7fc97f","#ef3b2c","#662506","#a6cee3","#fb9a99","#984ea3","#ffff33")), ...)

}

scale_colour_masterthesis <- function(...){
      library(scales)
      discrete_scale("colour","Publication",
                     manual_pal(values = c("#386cb0","#fdb462","#7fc97f","#ef3b2c","#662506","#a6cee3","#fb9a99","#984ea3","#ffff33")), ...)

}

```

# Masterarbeit Script

## Deskriptive Analysis

Data is read and prepared in separate file. The variable for the type of voter is created by filtering individuals that lived in the same community for at least ten consecutive votes. For each individual the 10 most recent votes were selected. This allows for the classification of these individuals into "never voters" (0-1 participation), "selective voters" (2-8 participation) and "always voters" (9-10 participation). 

```{r message=FALSE, warning=FALSE}
setwd("/Users/alinelaurametzler/Documents/Universität/Master/Master Thesis/MA-Code/")

 # Load the data again
load("/Users/alinelaurametzler/Documents/Universität/Master/Master Thesis/MA-Code/Data/PreparedData/data.RData")

# source("MA_adminDataPreparation.R", local = knitr::knit_global())
```

### Distribution of voter types

Share of voter types over the years (for SG city)

```{r message=FALSE, warning=FALSE}
# From 2013 to 2020 always show percentage of voter types (nur für Stadt SG)

votertypeYear <- function(year, community){
  
  # Find voter types for individuals (same process as in MA_adminDataPreparation.R)
  data_name <- data %>% 
    filter(abstimmungsjahr <= year) %>% 
    filter(bfsnr == community) %>% 
    select(id_ek, abstimmungsjahr, abstimmungsmonat, id_ek, ID_move_change, beteiligt)%>% 
    arrange(id_ek, ID_move_change, abstimmungsjahr, abstimmungsmonat) %>% 
    group_by(id_ek, ID_move_change) %>% 
    dplyr::mutate(abst_reihe = row_number()) %>% 
    ungroup()
  
  data_name <- data_name %>% 
    group_by(id_ek, ID_move_change) %>% 
    dplyr::mutate(anz_folg_abst = max(abst_reihe)) %>% 
    filter(anz_folg_abst >= 10) %>% 
    ungroup() 
  
  data_name <- data_name %>% 
    group_by(id_ek) %>%
    dplyr::mutate(ind_mostrecent = max(ID_move_change)) %>% 
    filter(ID_move_change %in% ind_mostrecent) 
  
  data_name <- data_name %>% 
    arrange(id_ek, desc(abst_reihe)) %>% 
    group_by(id_ek) %>%
    slice(1:10) %>% 
    arrange(id_ek, abst_reihe) 
  
   data_name <- data_name %>% 
    group_by(id_ek) %>% 
    dplyr::mutate(beteiligt = case_when(
      beteiligt == "mit Stimmbeteiligung" ~ 1,
      TRUE ~ 0
    )) %>% 
    dplyr::mutate(anz_teilnahme = sum(beteiligt)) %>% 
    filter(abstimmungsjahr == year) %>% 
    filter(abst_reihe == max(abst_reihe)) %>% 
    select(-abstimmungsmonat, -ID_move_change, -beteiligt, -abst_reihe, -ind_mostrecent, -anz_folg_abst) %>% 
    dplyr::mutate(vote_type = case_when(
      anz_teilnahme < 1 ~ "never voter",
      anz_teilnahme > 9 ~ "always voter",
      TRUE ~ "selective voter"
    )) %>% 
    dplyr::mutate(vote_type_det = case_when(
      anz_teilnahme <1 ~ "never voter",
      anz_teilnahme >= 1 & anz_teilnahme < 4 ~ "seldom voter",
      anz_teilnahme >= 4 & anz_teilnahme < 7 ~ "occasional voter",
      anz_teilnahme >= 7 & anz_teilnahme < 10 ~ "frequent voter",
      TRUE ~ "always voter"
    )) 
   data_name
} 

data_2013 <- votertypeYear(2013, 3203)
data_2014 <- votertypeYear(2014, 3203)
data_2015 <- votertypeYear(2015, 3203)
data_2016 <- votertypeYear(2016, 3203)
data_2017 <- votertypeYear(2017, 3203)
data_2018 <- votertypeYear(2018, 3203)
data_2019 <- votertypeYear(2019, 3203)
data_2020 <- votertypeYear(2020, 3203)

VoterTypeShare<- function(data_name){
  
  dataYear <- data_name
  # With the voter type of every individual, the share can be calculated
  data_shares_t1 <- dataYear %>% 
    mutate(type = "vote_type") %>% 
    select(abstimmungsjahr, type, vote_type) %>% 
    group_by(abstimmungsjahr, type, vote_type) %>% 
    summarise(count = n()) %>% 
    ungroup() %>% 
    mutate(share = count/sum(count))
  
  data_shares_t2 <- dataYear %>% 
    mutate(type = "vote_type_det") %>% 
    select(abstimmungsjahr, type, vote_type_det) %>% 
    dplyr::rename(vote_type = vote_type_det) %>% 
    group_by(abstimmungsjahr, type, vote_type) %>% 
    summarise(count = n()) %>%
    ungroup() %>% 
    mutate(share = count/sum(count))
  
  share_vote_type <- data_shares_t1 %>% 
    bind_rows(data_shares_t2)
  
  rm(dataYear, data_shares_t1, data_shares_t2)
  
  # Print result
  share_vote_type
}

data_2013 <- VoterTypeShare(data_2013)
data_2014 <- VoterTypeShare(data_2014)
data_2015 <- VoterTypeShare(data_2015)
data_2016 <- VoterTypeShare(data_2016)
data_2017 <- VoterTypeShare(data_2017)
data_2018 <- VoterTypeShare(data_2018)
data_2019 <- VoterTypeShare(data_2019)
data_2020 <- VoterTypeShare(data_2020)

share_votertypes <- data_2013 %>% 
  bind_rows(data_2014, data_2015, data_2016, data_2017, data_2018, data_2019, data_2020)

rm(data_2013, data_2014, data_2015, data_2016, data_2017, data_2018, data_2019, data_2020)



# Show in stacked area chart
plot_votertypes_share <- share_votertypes %>% 
  filter(type == "vote_type") %>% 
  mutate(vote_type =  fct_relevel(vote_type, c("never voter", "selective voter", "always voter"))) %>% 
  ggplot(aes(x=abstimmungsjahr, y=share, fill=vote_type)) + 
  geom_area(alpha=0.6 , size=0.2, colour="black") +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_masterthesis()+
  theme_masterthesis() +
  labs(title = "Abstimmungstypen im Zeitverlauf",
       subtitle = "Die Ergebnisse beschränken sich auf die 10 jüngsten Abstimmungen \nder Jahre für die Stadt St. Gallen",
       x = "Abstimmungsjahr",
       y = "Kummulativer Anteil",
       fill = "Abstimmungstyp: ")
plot_votertypes_share

plot_votertypesdet_share <- share_votertypes %>% 
  filter(type == "vote_type_det") %>% 
  mutate(vote_type =  fct_relevel(vote_type, c("never voter","seldom voter","occasional voter","frequent voter","always voter"))) %>% 
  ggplot(aes(x=abstimmungsjahr, y=share, fill=vote_type)) + 
  geom_area(alpha=0.6 , size=0.2, colour="black") +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_masterthesis()+
  theme_masterthesis() +
  labs(title = "Abstimmungstypen im Zeitverlauf",
       subtitle = "Die Ergebnisse beschränken sich auf die 10 jüngsten Abstimmungen \nder Jahre für die Stadt St. Gallen",
       x = "Abstimmungsjahr",
       y = "Kummulativer Anteil",
       fill = "Abstimmungstyp: ")
plot_votertypesdet_share
```

### Kumulativer Anteil von Beteiligungshäufigkeit an Abstimmungen

```{r message=FALSE, warning=FALSE}
cummulative_shares_bet <- data_mlogit %>% 
  group_by(anz_teilnahme) %>% 
  summarise(count = n()) %>% 
  mutate(cum = cumsum(count)/sum(count)) %>% 
  rename(`Anzahl Teilnahme` = anz_teilnahme,
         `Anzahl Individuen` = count,
         `Kummulative Häufigkeit` = cum)

# library(xtable)
# table <- xtable(cummulative_shares_bet)
# print(table)
library(reactable)
reactable(cummulative_shares_bet, 
          defaultPageSize = 15,
          columns = list(`Kummulative Häufigkeit` = colDef(format = colFormat(percent = TRUE, digits = 1))))

```

### Distribution of income and wealth in the voter type groups


```{r message=FALSE, warning=FALSE}
income_dist_votertypes <- data_mlogit %>% 
  filter(!is.na(steuer_tarif_imputed)) %>% 
  ggplot(aes(x = massgebendesEinkommen_imputed, group = vote_type, fill = vote_type)) +
  geom_density(adjust = 1.5, alpha = .4) +
  facet_wrap(~ steuer_tarif_imputed) +
  scale_fill_masterthesis()+
  theme_masterthesis()
income_dist_votertypes

wealth_dist_votertypes <- data_mlogit %>% 
  filter(reinvermoegen_imputed >= -20000) %>% 
  ggplot(aes(x = reinvermoegen_imputed, group = vote_type, fill = vote_type)) +
  geom_density(adjust = 1.5, alpha = .4) +
  facet_wrap(~ steuer_tarif_imputed) +
  scale_fill_masterthesis()+
  theme_masterthesis()
wealth_dist_votertypes

hhincome_dist_votertypes <- data_mlogit %>% 
  filter(!is.na(steuer_tarif_imputed)) %>% 
  filter(hhaequEinkommen < 200000) %>%          
  ggplot(aes(x = hhaequEinkommen, group = vote_type, fill = vote_type)) +
  geom_density(adjust = 1.5, alpha = .4) +
  facet_wrap(~ steuer_tarif_imputed) +
  scale_fill_masterthesis()+
  theme_masterthesis()
hhincome_dist_votertypes
```

Haben die Voter Types statistisch signifikante Unterschiede bezgl. Einkommen und Vermögen?

-->Since tax variables are truncated at the top I use the median for the t-test

```{r message=FALSE, warning=FALSE}

data_mlogit %>% 
  group_by(steuer_tarif_imputed, vote_type) %>%  
  filter(!is.na(steuer_tarif_imputed)) %>% 
  summarise(Eink_Median = median(steuerb_einkommen_imputed, na.rm = TRUE),
            HHaequ_Median = median(hhaequEinkommen, na.rm = TRUE),
            Verm_Median = median(reinvermoegen_imputed, na.rm = TRUE),
            HHVerm_Median = median(hhaequVermoegen, na.rm = TRUE),
            Eink_Mean = mean(steuerb_einkommen_imputed, na.rm = TRUE),
            HHaequ_Mean = mean(hhaequEinkommen, na.rm = TRUE),
            Verm_Mean = mean(reinvermoegen_imputed, na.rm = TRUE),
            HHVerm_Mean = mean(hhaequVermoegen, na.rm = TRUE))


# Are the differences statistically significant?
# Should I group it by steuer_tarif?
# Evtl with median instead of mean.. There the truncation would not matter

# Answer Stackoverflow:
# You can use the wilcoxons igned-rank-test to calculate the statistical significance of paired data 
# given the null hypothesis that the median difference between two paired variables is zero
# https://statsandr.com/blog/wilcoxon-test-in-r-how-to-compare-2-groups-under-the-non-normality-assumption/
data_verhtarif <- data_mlogit %>% 
  filter(steuer_tarif_imputed == "verheiratet") %>% 
  filter(vote_type %in% c("never voter", "always voter"))
data_ledigtarif <- data_mlogit %>% 
  filter(steuer_tarif_imputed == "alleinstehend/unverheiratet") %>% 
  filter(vote_type %in% c("selective voter", "always voter"))


test <- wilcox.test(data_verhtarif$steuerb_einkommen_imputed ~ data_verhtarif$vote_type,
                    alternative = "less")
test

```



### Scatter Plot Einkommen und Anz. Teilnahmen bei 10 Abstimmungen

H1A/B

```{r message=FALSE, warning=FALSE}
summary(data_mlogit$massgebendesEinkommen_imputed)
summary(data_mlogit$anz_teilnahme)


plot_scatter <- data_mlogit %>% 
  mutate(massgebendesEinkommen_imputed = case_when(
    massgebendesEinkommen_imputed < 0 ~ 0,
    TRUE ~ massgebendesEinkommen_imputed
  )) %>% 
  ggplot(aes(x = massgebendesEinkommen_imputed, y = anz_teilnahme)) +
  # geom_bin2d(bins = 10)
  geom_jitter(alpha = 0.1) +
  geom_smooth() +
  theme_minimal()
plot_scatter

plot_scatter_age <- data_mlogit %>% 
  filter(!is.na(alter_c)) %>% 
  mutate(massgebendesEinkommen_imputed = case_when(
    massgebendesEinkommen_imputed < 0 ~ 0,
    TRUE ~ massgebendesEinkommen_imputed
  )) %>% 
  ggplot(aes(x = massgebendesEinkommen_imputed, y = anz_teilnahme)) +
  geom_jitter(alpha = 0.1) +
  geom_smooth() +
  facet_wrap(~ alter_c) +
  theme_minimal()
plot_scatter_age

plot_scatter_sex <- data_mlogit %>% 
  filter(!is.na(sex_c)) %>% 
  mutate(massgebendesEinkommen_imputed = case_when(
    massgebendesEinkommen_imputed < 0 ~ 0,
    TRUE ~ massgebendesEinkommen_imputed
  )) %>% 
  ggplot(aes(x = massgebendesEinkommen_imputed, y = anz_teilnahme)) +
  geom_jitter(alpha = 0.1) +
  geom_smooth() +
  facet_wrap(~ sex_c) +
  theme_minimal()
plot_scatter_sex


```

### Multinomial Logit Model
Was ist der Unterschied zwischen mlogit() und multinom()? Weshalb funktioniert mlogit() nicht und multinom() schon?

H1.1A/B

```{r message=FALSE, warning=FALSE}
# library(mlogit)
#
# # Generating the Person-Choice Matrix
# data_mlogitprep <- as.data.frame(data_mlogit) %>% 
#   select(vote_type, alter_c, sex_c, konfession_c, residenz10, zugezogen, mEinkommen_c, Vermoegen_c) %>% 
#   na.omit()
# data_mlogit.pc <- mlogit.data(data_mlogitprep,
#                               varying = 2:8,
#                               choice = "vote_type",
#                               shape = "wide",
#                               sep = "_")
# head(data_mlogit.pc)
# 
# mlogit.fit <- mlogit(vote_type ~ 0 | alter_c + sex_c + konfession_c + residenz10 + zugezogen + mEinkommen_c + Vermoegen_c,
#                           shape = "long",
#                           data = data_mlogit.pc)

library(nnet)
library(stargazer)
mlogit <- multinom(vote_type ~ alter_c + sex_c + konfession_c + residenz10 + zugezogen + mEinkommen_c + Vermoegen_c,
                   data = data_mlogit)
stargazer(mlogit, type = "text")
```


```{r message=FALSE, warning=FALSE}
mlogit_det <- multinom(vote_type_det ~ alter_c + sex_c + konfession_c + residenz10 + zugezogen + mEinkommen_c + Vermoegen_c,
                   data = data_mlogit15)
stargazer(mlogit_det, type = "text")
```

### Effect of age on political participation for different income quartiles

H2

```{r message=FALSE, warning=FALSE}
plot_scatter_ageincome <- data_mlogit %>% 
  filter(!is.na(mEinkommen_c)) %>% 
  mutate(massgebendesEinkommen_imputed = case_when(
    massgebendesEinkommen_imputed < 0 ~ 0,
    TRUE ~ massgebendesEinkommen_imputed
  )) %>% 
  ggplot(aes(x = alter_v, y = anz_teilnahme)) +
  geom_jitter(alpha = 0.1) +
  geom_smooth() +
  facet_wrap(~ mEinkommen_c) +
  theme_minimal()
plot_scatter_ageincome


plot_scatter_agevermoegen <- data_mlogit %>% 
  filter(!is.na(mEinkommen_c)) %>% 
  mutate(massgebendesEinkommen_imputed = case_when(
    massgebendesEinkommen_imputed < 0 ~ 0,
    TRUE ~ massgebendesEinkommen_imputed
  )) %>% 
  ggplot(aes(x = alter_v, y = anz_teilnahme)) +
  # geom_point() +
  # geom_jitter() +
  geom_smooth() +
  facet_wrap(~ Vermoegen_c) +
  theme_minimal()
plot_scatter_agevermoegen


plot_scatter_age
```

### Effect of jumps in income/wealth

H3A/B

Identify the jumps

->Since we only have income per year -->participation as share (sum(partic)/sum(all_votes))
-->then look for jumps in yearly income
-->compare share of participation before and after


Possible distinctions:
1)	From no income to some income
2)	From some income to no income
3)	From some income to less than 50% of that income
4)	From some income to less than 75% of that income

TODO: Do you have a recommendation for defining jumps of income/wealth? And should I address it seperately in the paper?

```{r message=FALSE, warning=FALSE}
library(data.table) 

# TODO: write function to just specify income/wealth and the wanted distinction of jumps

# get aggregated data by year for respondents
data_year <- data %>% 
  mutate(anz_teilnahme = case_when(
    beteiligt == "mit Stimmbeteiligung" ~ 1,
    TRUE ~ 0
  )) %>% 
  mutate(anz_abstimmungen = case_when(
    beteiligt == "mit Stimmbeteiligung" ~ 1,
    beteiligt == "keine Stimmbeteiligung" ~ 1
  )) %>% 
  group_by(id_ek, abstimmungsjahr) %>%
  summarise(anz_teilnahme = sum(anz_teilnahme),
            anz_abstimmungen = sum(anz_abstimmungen),
            share_teilnahme = anz_teilnahme/anz_abstimmungen,
            sex = last(sex_imp),
            alter = mean(alter_v, na.rm=TRUE),
            konfession = last(konfession_imp),
            residenz = mean(residenz_imp, na.rm=TRUE),
            zugezogen = last(zugezogen),
            einkommen = mean(massgebendesEinkommen_imputed, na.rm=TRUE),
            vermoegen = mean(reinvermoegen_imputed, na.rm=TRUE)
            ) %>% 
  distinct() %>% 
  ungroup() 

# Identify individuals with bigger changes in income or wealth
data_year <- data_year %>% 
  group_by(id_ek) %>% 
  # calculate change compared to previous year
  mutate(change_eink = 100 * (einkommen - lag(einkommen, default = NA))/lag(einkommen, default = NA)) %>% 
  mutate(change_verm = 100 * (vermoegen - lag(vermoegen, default = NA))/lag(vermoegen, default = NA)) %>% 
  # Identify big changes in income/wealth
  # TODO: when is change considered to be big? (after 50% change?)
  mutate(bigchange_eink50 = case_when(
    change_eink >= 20 ~ 5,
    change_eink >= 50 ~ 1,
    change_eink <= -50 ~ 2,
    TRUE ~ 0
  )) %>% 
  mutate(bigchange_verm50 = case_when(
    change_verm >= 20 ~ 5,
    change_verm >= 50 ~ 1,
    change_verm <= -50 ~ 2,
    TRUE ~ 0
  )) %>% 
  mutate(bigchange_eink75 = case_when(
    change_eink >= 20 ~ 5,
    change_eink >= 50 ~ 1,
    change_eink <= -75 ~ 3,
    TRUE ~ 0
  )) %>% 
  mutate(bigchange_verm75 = case_when(
    change_verm >= 20 ~ 5,
    change_verm >= 50 ~ 1,
    change_verm <= -75 ~ 3,
    TRUE ~ 0
  )) %>% 
  # create variable to detect individuals with treatment (i.e. big income drop)
  # Only valid when also wealth dropped (otherwise just income shift)
  mutate(treat_less50income = case_when(
    bigchange_eink50 == 2 & bigchange_verm50 %in% c(0, 5) ~ 1,
    TRUE ~ 0
  )) %>% 
  mutate(treat_less50wealth = case_when(
    bigchange_verm50 == 2 & bigchange_eink50 %in% c(0, 5) ~ 1,
    TRUE ~ 0
  )) %>% 
  mutate(treat_less75income = case_when(
    bigchange_eink75 == 3 & bigchange_verm75 %in% c(0, 5) ~ 1,
    TRUE ~ 0
  )) %>% 
  mutate(treat_less75wealth = case_when(
    bigchange_verm75 == 3 & bigchange_eink75 %in% c(0, 5) ~ 1,
    TRUE ~ 0
  )) 


data_year <- data_year %>%
  # for multiple income/wealth shocks only take first one
  group_by(id_ek) %>%
  mutate(inc_change50 = as.numeric(rle(treat_less50income)$lengths %>% {rep(seq(length(.)), .)})) %>% 
  mutate(wealth_change50 = as.numeric(rle(treat_less50wealth)$lengths %>% {rep(seq(length(.)), .)})) %>% 
  mutate(inc_change75 = as.numeric(rle(treat_less75income)$lengths %>% {rep(seq(length(.)), .)})) %>% 
  mutate(wealth_change75 = as.numeric(rle(treat_less75wealth)$lengths %>% {rep(seq(length(.)), .)})) %>%
  ungroup() %>% 
  mutate(inc_change50 = case_when(
    inc_change50 > 2 ~ 3,
    TRUE ~ inc_change50
  )) %>% 
  mutate(wealth_change50 = case_when(
    wealth_change50 > 2 ~ 3,
    TRUE ~ wealth_change50
  )) %>% 
  mutate(treatment_year_inc50 = case_when(
    inc_change50 == 2 ~ abstimmungsjahr,
    TRUE ~ NA_integer_
  )) %>% 
  mutate(treatment_year_wealth50 = case_when(
    wealth_change50 == 2 ~ abstimmungsjahr,
    TRUE ~ NA_integer_
  )) %>% 
  mutate(inc_change75 = case_when(
    inc_change75 > 3 ~ 3,
    TRUE ~ inc_change75
  )) %>% 
  mutate(wealth_change75 = case_when(
    wealth_change75 > 3 ~ 3,
    TRUE ~ wealth_change75
  )) %>% 
  mutate(treatment_year_inc75 = case_when(
    inc_change75 == 3 ~ abstimmungsjahr,
    TRUE ~ NA_integer_
  )) %>% 
  mutate(treatment_year_wealth75 = case_when(
    wealth_change75 == 3 ~ abstimmungsjahr,
    TRUE ~ NA_integer_
  )) %>% 
  group_by(id_ek) %>% 
  fill(treatment_year_inc50, .direction = "updown") %>% 
  fill(treatment_year_wealth50, .direction = "updown") %>% 
  fill(treatment_year_inc75, .direction = "updown") %>% 
  fill(treatment_year_wealth75, .direction = "updown") %>% 
  mutate(treat_less50income = case_when(
    !is.na(treatment_year_inc50) ~ 1,
    TRUE ~ 0
  )) %>% 
  mutate(treat_less50wealth = case_when(
    !is.na(treatment_year_wealth50) ~ 1,
    TRUE ~ 0
  )) %>% 
  mutate(treat_less75income = case_when(
    !is.na(treatment_year_inc75) ~ 1,
    TRUE ~ 0
  )) %>% 
  mutate(treat_less75wealth = case_when(
    !is.na(treatment_year_wealth75) ~ 1,
    TRUE ~ 0
  )) %>% 
  # create var years from/to treatment. For the never-treated (i.e. control) units,
  # we'll set the "time_to_treatment" value at 0 for the middle year.
  mutate(treatment_year_inc50 = 
           ifelse(is.na(treatment_year_inc50), round(mean(abstimmungsjahr)), treatment_year_inc50)) %>% 
  mutate(treatment_year_wealth50 = 
           ifelse(is.na(treatment_year_wealth50), round(mean(abstimmungsjahr)), treatment_year_wealth50)) %>% 
  mutate(time_to_treat_inc50 = ifelse(treat_less50income == 1, (abstimmungsjahr - treatment_year_inc50), 0)) %>% 
  mutate(time_to_treat_wealth50 = ifelse(treat_less50wealth == 1, (abstimmungsjahr - treatment_year_wealth50), 0)) %>% 
  mutate(treatment_year_inc75 = 
           ifelse(is.na(treatment_year_inc75), round(mean(abstimmungsjahr)), treatment_year_inc75)) %>% 
  mutate(treatment_year_wealth75 = 
           ifelse(is.na(treatment_year_wealth75), round(mean(abstimmungsjahr)), treatment_year_wealth75)) %>% 
  mutate(time_to_treat_inc75 = ifelse(treat_less75income == 1, (abstimmungsjahr - treatment_year_inc75), 0)) %>% 
  mutate(time_to_treat_wealth75 = ifelse(treat_less75wealth == 1, (abstimmungsjahr - treatment_year_wealth75), 0))
  

```


### Difference-in-Differences Event Study 
Help: https://lost-stats.github.io/Model_Estimation/Research_Design/event_study.html



```{r message=FALSE, warning=FALSE}
library(fixest) 
# TODO: do I need to account for all control variables in the diff-in-diff model? 
# -->how should I handle the categorical ones?

# income shocks
mod_twfe = feols(share_teilnahme ~ i(time_to_treat_inc50, treat_less50income, ref = -1) + ## key interaction: time × treatment status
		  alter + einkommen |               ## Other controls
		  id_ek + abstimmungsjahr,                  ## FEs
		 cluster = ~id_ek,                          ## Clustered SEs
		 data = data_year)


iplot(mod_twfe, 
      xlab = 'Time to treatment',
      main = 'Event-Study of the Effects of Neg. Income Shocks on Voter Turnout (TWFE)')


# wealth shocks
mod_twfe2 = feols(share_teilnahme ~ i(time_to_treat_wealth50, treat_less50income, ref = -1) + ## key interaction: time × treatment status
		  alter + vermoegen |               ## Other controls
		  id_ek + abstimmungsjahr,                  ## FEs
		 cluster = ~id_ek,                          ## Clustered SEs
		 data = data_year)


iplot(mod_twfe2, 
      xlab = 'Time to treatment',
      main = 'Event-Study of the Effects of Neg. Wealth Shocks on Voter Turnout (TWFE)')


# income shocks
mod_twfe = feols(share_teilnahme ~ i(time_to_treat_inc75, treat_less75income, ref = -1) + ## key interaction: time × treatment status
		  alter + einkommen |               ## Other controls
		  id_ek + abstimmungsjahr,                  ## FEs
		 cluster = ~id_ek,                          ## Clustered SEs
		 data = data_year)


iplot(mod_twfe, 
      xlab = 'Time to treatment',
      main = 'Event-Study of the Effects of Neg. Income (-75%) Shocks on Voter Turnout (TWFE)')


# wealth shocks
mod_twfe2 = feols(share_teilnahme ~ i(time_to_treat_wealth75, treat_less75income, ref = -1) + ## key interaction: time × treatment status
		  alter + vermoegen |               ## Other controls
		  id_ek + abstimmungsjahr,                  ## FEs
		 cluster = ~id_ek,                          ## Clustered SEs
		 data = data_year)


iplot(mod_twfe2, 
      xlab = 'Time to treatment',
      main = 'Event-Study of the Effects of Neg. Wealth (-75%) Shocks on Voter Turnout (TWFE)')
```



The effect of income is very different depending on the age category!




```{r message=FALSE, warning=FALSE}
plot_scatter_sex
```


### Je geringer die empfundene Relevanz einer Abstimmung ist, desto groesser ist die Rolle, welche das Einkommen bei der Beteiligung am Urnengang spielt. 

TODO: Is there a better method to compare the effect of the independent on the dependent variable than just subsetting the group and looking at the estimates?

```{r message=FALSE, warning=FALSE}
votes <- read.csv("/Users/alinelaurametzler/Documents/Universität/Master/Master Thesis/MA-Code/Data/PreparedData/votes_data_short.csv", encoding = "UTF-8")

# select votes with low/high importance (i.e. lowest/highest quartile of importance)
votes_lowimp <- votes %>% 
  filter(quantile(importance, 0.25) >= importance) %>% 
  select(datum, titel_kurz_d, jour, mois, annee, importance)
votes_highimp <- votes %>% 
  filter(quantile(importance, 0.75) <= importance) %>% 
  select(datum, titel_kurz_d, jour, mois, annee, importance)

# join with admin. data
turnout_lowimp <- votes_lowimp %>% 
  left_join(data, by = "datum")
turnout_highimp <- votes_highimp %>% 
  left_join(data, by = "datum")


# multinomial logit model
mlogit_lowimp <- multinom(beteiligt ~ alter_c + sex_c + konfession_c + residenz10 + zugezogen + mEinkommen_c + Vermoegen_c,
                   data = turnout_lowimp)
mlogit_highimp <- multinom(beteiligt ~ alter_c + sex_c + konfession_c + residenz10 + zugezogen + mEinkommen_c + Vermoegen_c,
                   data = turnout_highimp)

stargazer(mlogit_lowimp, mlogit_highimp, type = "text")
```

### Bei Abstimmungen mit einem grösseren Umverteilungsaspekt spielt das Einkommen eine grössere Rolle bei der Beteiligung am Urnengang.


```{r message=FALSE, warning=FALSE}


# 10.2	Sozialversicherungen
# 6.1	Steuerwesen

votes_umverteilung <- votes %>% 
  filter(d1e2 %in% c(6.1, 10.2))

votes_steuern <- votes %>% 
  filter(d1e2 == 6.1)


# join with admin. data
turnout_umverteilung<- votes_umverteilung %>% 
  left_join(data, by = "datum")
turnout_steuern <- votes_steuern %>% 
  left_join(data, by = "datum")


# multinomial logit model
mlogit_umverteilung <- multinom(beteiligt ~ alter_c + sex_c + konfession_c + residenz10 + zugezogen + mEinkommen_c + Vermoegen_c,
                   data = turnout_umverteilung)
mlogit_steuern <- multinom(beteiligt ~ alter_c + sex_c + konfession_c + residenz10 + zugezogen + mEinkommen_c + Vermoegen_c,
                   data = turnout_steuern)

stargazer(mlogit_umverteilung, mlogit_steuern, type = "text")
```

### Der Effekt von hohem Einkommen überträgt sich auch auf die Beteiligung am Urnengang anderer Personen, welche im selben Haushalt leben.


Compare households with high income/wealth to households with low income wealth

Compare highest earning person of household to other members that have less income/wealth
-->Especially look at adult children that still live with parents


```{r message=FALSE, warning=FALSE}
# TODO: can I just  define children by their age group (18-25) living with older age group (35-65)?
# -->what about couples, shared flats with bigger age gaps? (right now I just ignore this)
data_households <- data %>% 
  ungroup() %>% 
  filter(haushalttyp_sw_2 == "Mehrpersonenhaushalte") %>% 
  filter(generationen_sw %in% c("Zwei Generationen", "Drei Generationen", "Vier Generationen")) %>% 
  mutate(young_pers = case_when(
    alter_v <= 25 ~ 1,
    TRUE ~ 0
  )) %>% 
  mutate(older_pers = case_when(
    alter_v > 35 & alter_v <= 65 ~ 1,
    TRUE ~ 0
  )) %>% 
  group_by(householdID_sw) %>% 
  # all housholds (mind. 2 generations) with young people and older people in them
  filter(sum(young_pers) >= 1 & sum(older_pers) >= 1) %>% 
  # create variable to sum income of parents (=older_pers in household)
  group_by(householdID_sw, older_pers) %>% 
  mutate(income_older = case_when(
    # married couples have joined incomes
    steuer_tarif_imputed == "verheiratet" & older_pers == 1 ~ massgebendesEinkommen_imputed,
    steuer_tarif_imputed == "alleinstehend/unverheiratet" & older_pers == 1 ~ sum(massgebendesEinkommen_imputed) ,
    TRUE ~ NA_real_
  )) %>% 
  ungroup() %>% 
  group_by(householdID_sw) %>% 
  fill(income_older, .direction = "updown") %>% 
  filter(young_pers == 1) %>% 
  ungroup() %>% 
  filter(!is.na(income_older)) %>% 
  # take one random vote date per individual
  group_by(id_ek) %>%
  sample_n(1)


# households with low income of parents
data_households_low <- data_households %>% 
  ungroup() %>% 
  filter(quantile(income_older, 0.25) >= income_older) 

mlogit_household_low <- multinom(beteiligt ~  alter_c + sex_c + konfession_c + residenz10 + zugezogen + income_older+ mEinkommen_c + Vermoegen_c,
                   data = data_households_low)



# households with high income of parents
data_households_high <- data_households %>% 
  filter(quantile(income_older, 0.75) <= income_older) 

mlogit_household_high <- multinom(beteiligt ~  alter_c + sex_c + konfession_c + residenz10 + zugezogen + income_older + mEinkommen_c + Vermoegen_c,
                   data = data_households_high)

stargazer(mlogit_household_low, mlogit_household_high, type = "text")

```



