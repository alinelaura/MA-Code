---
title: "Masterthesis script"
author: "Aline Laura Metzler"
date: "5/26/2022"
output:
  pdf_document:
    latex_engine: xelatex
---

```{r setup, include=FALSE}
# knitr::opts_chunk$set(echo = TRUE)
```



```{r message=FALSE, warning=FALSE}
library(ggplot2)
library(tidyverse)
library(dplyr)
library(forcats)
library(ggplot2)
library(forcats)
```

# Create a custom theme for the plots

```{r}
# define a theme function
theme_masterthesis <- function(base_size=12, base_family="Times New Roman") {
      library(grid)
      library(ggthemes)
      library(extrafont)
      (theme_foundation(base_size=base_size, base_family=base_family) + 
          theme(plot.title = element_text(face = "bold",
                                         size = rel(1.2)),
               plot.subtitle = element_text(face = "italic",
                                         size = rel(1)),
               text = element_text(),
               panel.background = element_rect(colour = NA),
               plot.background = element_rect(colour = NA),
               panel.border = element_rect(colour = NA),
               axis.title = element_text(face = "bold",size = rel(1)),
               axis.title.y = element_text(angle=90,vjust =2),
               axis.title.x = element_text(vjust = -0.2),
               axis.text = element_text(), 
               axis.line = element_line(colour="black"),
               axis.ticks = element_line(),
               panel.grid.major = element_line(colour="#f0f0f0"),
               panel.grid.minor = element_blank(),
               legend.key = element_rect(colour = NA),
               legend.position = "bottom",
               legend.direction = "horizontal",
               legend.key.size= unit(0.2, "cm"),
               legend.margin = unit(0, "cm"),
               legend.title = element_text(face="italic"),
               plot.margin=unit(c(10,5,5,5),"mm"),
               strip.background=element_rect(colour="#f0f0f0",fill="#f0f0f0"),
               strip.text = element_text(face="bold")
          ))
      
}

# TODO: Define color scheme
# Define Color scales for Charts
scale_fill_masterthesis <- function(...){
      library(scales)
      discrete_scale("fill","Publication",
                     manual_pal(values = c("#386cb0","#fdb462","#7fc97f","#ef3b2c","#662506","#a6cee3","#fb9a99","#984ea3","#ffff33")), ...)

}

scale_colour_masterthesis <- function(...){
      library(scales)
      discrete_scale("colour","Publication",
                     manual_pal(values = c("#386cb0","#fdb462","#7fc97f","#ef3b2c","#662506","#a6cee3","#fb9a99","#984ea3","#ffff33")), ...)

}

```

# Masterarbeit Script

## Deskriptive Analysis

Data is read and prepared in separate file. The variable for the type of voter is created by filtering individuals that lived in the same community for at least ten consecutive votes. For each individual the 10 most recent votes were selected. This allows for the classification of these individuals into "never voters" (0-1 participation), "selective voters" (2-8 participation) and "always voters" (9-10 participation). 

```{r message=FALSE, warning=FALSE}
setwd("/Users/alinelaurametzler/Documents/Universität/Master/Master Thesis/MA-Code/")

 # Load the the three data sets from MA_adminDataPreparation.R
load("/Users/alinelaurametzler/Documents/Universität/Master/Master Thesis/MA-Code/Data/PreparedData/data.RData")


# source("MA_adminDataPreparation.R", local = knitr::knit_global())
```

### Distribution of voter types

Share of voter types over the years (for SG city)

```{r message=FALSE, warning=FALSE}
# From 2013 to 2020 always show percentage of voter types (nur für Stadt SG)

votertypeYear <- function(year, community){
  
  # Find voter types for individuals (same process as in MA_adminDataPreparation.R)
  data_name <- data %>% 
    filter(abstimmungsjahr <= year) %>% 
    filter(bfsnr == community) %>% 
    select(id_ek, abstimmungsjahr, abstimmungsmonat, id_ek, ID_move_change, beteiligt)%>% 
    arrange(id_ek, ID_move_change, abstimmungsjahr, abstimmungsmonat) %>% 
    group_by(id_ek, ID_move_change) %>% 
    dplyr::mutate(abst_reihe = row_number()) %>% 
    ungroup()
  
  data_name <- data_name %>% 
    group_by(id_ek, ID_move_change) %>% 
    dplyr::mutate(anz_folg_abst = max(abst_reihe)) %>% 
    filter(anz_folg_abst >= 10) %>% 
    ungroup() 
  
  data_name <- data_name %>% 
    group_by(id_ek) %>%
    dplyr::mutate(ind_mostrecent = max(ID_move_change)) %>% 
    filter(ID_move_change %in% ind_mostrecent) 
  
  data_name <- data_name %>% 
    arrange(id_ek, desc(abst_reihe)) %>% 
    group_by(id_ek) %>%
    slice(1:10) %>% 
    arrange(id_ek, abst_reihe) 
  
   data_name <- data_name %>% 
    group_by(id_ek) %>% 
    dplyr::mutate(beteiligt = case_when(
      beteiligt == "mit Stimmbeteiligung" ~ 1,
      TRUE ~ 0
    )) %>% 
    dplyr::mutate(anz_teilnahme = sum(beteiligt)) %>% 
    filter(abstimmungsjahr == year) %>% 
    filter(abst_reihe == max(abst_reihe)) %>% 
    select(-abstimmungsmonat, -ID_move_change, -beteiligt, -abst_reihe, -ind_mostrecent, -anz_folg_abst) %>% 
    dplyr::mutate(vote_type = case_when(
      anz_teilnahme < 1 ~ "never voter",
      anz_teilnahme > 9 ~ "always voter",
      TRUE ~ "selective voter"
    )) %>% 
    dplyr::mutate(vote_type_det = case_when(
      anz_teilnahme <1 ~ "never voter",
      anz_teilnahme >= 1 & anz_teilnahme < 4 ~ "seldom voter",
      anz_teilnahme >= 4 & anz_teilnahme < 7 ~ "occasional voter",
      anz_teilnahme >= 7 & anz_teilnahme < 10 ~ "frequent voter",
      TRUE ~ "always voter"
    )) 
   data_name
} 

data_2013 <- votertypeYear(2013, 3203)
data_2014 <- votertypeYear(2014, 3203)
data_2015 <- votertypeYear(2015, 3203)
data_2016 <- votertypeYear(2016, 3203)
data_2017 <- votertypeYear(2017, 3203)
data_2018 <- votertypeYear(2018, 3203)
data_2019 <- votertypeYear(2019, 3203)
data_2020 <- votertypeYear(2020, 3203)

VoterTypeShare<- function(data_name){
  
  dataYear <- data_name
  # With the voter type of every individual, the share can be calculated
  data_shares_t1 <- dataYear %>% 
    mutate(type = "vote_type") %>% 
    select(abstimmungsjahr, type, vote_type) %>% 
    group_by(abstimmungsjahr, type, vote_type) %>% 
    summarise(count = n()) %>% 
    ungroup() %>% 
    mutate(share = count/sum(count))
  
  data_shares_t2 <- dataYear %>% 
    mutate(type = "vote_type_det") %>% 
    select(abstimmungsjahr, type, vote_type_det) %>% 
    dplyr::rename(vote_type = vote_type_det) %>% 
    group_by(abstimmungsjahr, type, vote_type) %>% 
    summarise(count = n()) %>%
    ungroup() %>% 
    mutate(share = count/sum(count))
  
  share_vote_type <- data_shares_t1 %>% 
    bind_rows(data_shares_t2)
  
  rm(dataYear, data_shares_t1, data_shares_t2)
  
  # Print result
  share_vote_type
}

data_2013 <- VoterTypeShare(data_2013)
data_2014 <- VoterTypeShare(data_2014)
data_2015 <- VoterTypeShare(data_2015)
data_2016 <- VoterTypeShare(data_2016)
data_2017 <- VoterTypeShare(data_2017)
data_2018 <- VoterTypeShare(data_2018)
data_2019 <- VoterTypeShare(data_2019)
data_2020 <- VoterTypeShare(data_2020)

share_votertypes <- data_2013 %>% 
  bind_rows(data_2014, data_2015, data_2016, data_2017, data_2018, data_2019, data_2020)

rm(data_2013, data_2014, data_2015, data_2016, data_2017, data_2018, data_2019, data_2020)



# Show in stacked area chart
plot_votertypes_share <- share_votertypes %>% 
  filter(type == "vote_type") %>% 
  mutate(vote_type =  fct_relevel(vote_type, c("never voter", "selective voter", "always voter"))) %>% 
  ggplot(aes(x=abstimmungsjahr, y=share, fill=vote_type)) + 
  geom_area(alpha=0.6 , size=0.2, colour="black") +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_masterthesis()+
  theme_masterthesis() +
  labs(title = "Abstimmungstypen im Zeitverlauf",
       subtitle = "Die Ergebnisse beschränken sich auf die 10 jüngsten Abstimmungen \nder Jahre für die Stadt St. Gallen",
       x = "Abstimmungsjahr",
       y = "Kummulativer Anteil",
       fill = "Abstimmungstyp: ")
plot_votertypes_share

plot_votertypesdet_share <- share_votertypes %>% 
  filter(type == "vote_type_det") %>% 
  mutate(vote_type =  fct_relevel(vote_type, c("never voter","seldom voter","occasional voter","frequent voter","always voter"))) %>% 
  ggplot(aes(x=abstimmungsjahr, y=share, fill=vote_type)) + 
  geom_area(alpha=0.6 , size=0.2, colour="black") +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_masterthesis()+
  theme_masterthesis() +
  labs(title = "Abstimmungstypen im Zeitverlauf",
       subtitle = "Die Ergebnisse beschränken sich auf die 10 jüngsten Abstimmungen \nder Jahre für die Stadt St. Gallen",
       x = "Abstimmungsjahr",
       y = "Kummulativer Anteil",
       fill = "Abstimmungstyp: ")
plot_votertypesdet_share
```

### Kumulativer Anteil von Beteiligungshäufigkeit an Abstimmungen

```{r message=FALSE, warning=FALSE}
cummulative_shares_bet <- data_mlogit %>% 
  group_by(anz_teilnahme) %>% 
  summarise(count = n()) %>% 
  mutate(cum = cumsum(count)/sum(count)) %>% 
  rename(`Anzahl Teilnahme` = anz_teilnahme,
         `Anzahl Individuen` = count,
         `Kummulative Häufigkeit` = cum)

# library(xtable)
# table <- xtable(cummulative_shares_bet)
# print(table)
library(reactable)
reactable(cummulative_shares_bet, 
          defaultPageSize = 15,
          columns = list(`Kummulative Häufigkeit` = colDef(format = colFormat(percent = TRUE, digits = 1))))

```

## H1: Distribution of income and wealth in the voter type groups


```{r message=FALSE, warning=FALSE}
income_dist_votertypes <- data_mlogit %>% 
  filter(!is.na(steuer_tarif_imputed)) %>% 
  ggplot(aes(x = massgebendesEinkommen_imputed, group = vote_type, fill = vote_type)) +
  geom_density(adjust = 1.5, alpha = .4) +
  facet_wrap(~ steuer_tarif_imputed) +
  scale_fill_masterthesis()+
  theme_masterthesis()
income_dist_votertypes

wealth_dist_votertypes <- data_mlogit %>% 
  filter(reinvermoegen_imputed >= -20000) %>% 
  ggplot(aes(x = reinvermoegen_imputed, group = vote_type, fill = vote_type)) +
  geom_density(adjust = 1.5, alpha = .4) +
  facet_wrap(~ steuer_tarif_imputed) +
  scale_fill_masterthesis()+
  theme_masterthesis()
wealth_dist_votertypes

hhincome_dist_votertypes <- data_mlogit %>% 
  filter(!is.na(steuer_tarif_imputed)) %>% 
  filter(hhaequEinkommen < 200000) %>%          
  ggplot(aes(x = hhaequEinkommen, group = vote_type, fill = vote_type)) +
  geom_density(adjust = 1.5, alpha = .4) +
  facet_wrap(~ steuer_tarif_imputed) +
  scale_fill_masterthesis()+
  theme_masterthesis()
hhincome_dist_votertypes
```

Haben die Voter Types statistisch signifikante Unterschiede bezgl. Einkommen und Vermögen?

-->Since tax variables are truncated at the top I use the median for the t-test

```{r message=FALSE, warning=FALSE}

data_mlogit %>% 
  group_by(steuer_tarif_imputed, vote_type) %>%  
  filter(!is.na(steuer_tarif_imputed)) %>% 
  summarise(Eink_Median = median(steuerb_einkommen_imputed, na.rm = TRUE),
            HHaequ_Median = median(hhaequEinkommen, na.rm = TRUE),
            Verm_Median = median(reinvermoegen_imputed, na.rm = TRUE),
            HHVerm_Median = median(hhaequVermoegen, na.rm = TRUE),
            Eink_Mean = mean(steuerb_einkommen_imputed, na.rm = TRUE),
            HHaequ_Mean = mean(hhaequEinkommen, na.rm = TRUE),
            Verm_Mean = mean(reinvermoegen_imputed, na.rm = TRUE),
            HHVerm_Mean = mean(hhaequVermoegen, na.rm = TRUE))


# Are the differences statistically significant?
# Should I group it by steuer_tarif?
# Evtl with median instead of mean.. There the truncation would not matter

# Answer Stackoverflow:
# You can use the wilcoxons igned-rank-test to calculate the statistical significance of paired data 
# given the null hypothesis that the median difference between two paired variables is zero
# https://statsandr.com/blog/wilcoxon-test-in-r-how-to-compare-2-groups-under-the-non-normality-assumption/
data_verhtarif <- data_mlogit %>% 
  filter(steuer_tarif_imputed == "verheiratet") %>% 
  filter(vote_type %in% c("never voter", "always voter"))
data_ledigtarif <- data_mlogit %>% 
  filter(steuer_tarif_imputed == "alleinstehend/unverheiratet") %>% 
  filter(vote_type %in% c("selective voter", "always voter"))


test <- wilcox.test(data_verhtarif$steuerb_einkommen_imputed ~ data_verhtarif$vote_type,
                    alternative = "less")
test

```


## H2: Effekt of Income & Wealth on political Participation (compared)
ordinal logit model

-->Need to check proportional odds with Wald test
-->Brant test also tests proportional odds assumption
-->if proportional odds assumption fails then need to turn to multinomial logit models

```{r message=FALSE, warning=FALSE}
library(brant)
library(glm.predict)
# library(haven)
library(stargazer)

data_mlogit_h2 <- data_mlogit %>% 
  mutate(steuerb_einkommen_imputed1000k = steuerb_einkommen_imputed/1000,
         massgebendesEinkommen_imputed1000k = massgebendesEinkommen_imputed/1000,
         reinvermoegen_imputed1000k = reinvermoegen_imputed/1000,
         hhaequEinkommen1000k = hhaequEinkommen/1000,
         hhaequVermoegen1000k = hhaequVermoegen/1000) %>% 
  mutate(anz_teilnahme = factor(anz_teilnahme,
                                levels = c(0,1,2,3,4,5,6,7,8,9,10),
                                labels = c("0","1","2","3","4","5","6","7","8","9","10")))


#Build ordinal logistic regression model
ologit_empty = polr(anz_teilnahme ~ alter_v + sex_c + konfession_c + residenz10 + zugezogen, 
                    data = data_mlogit_h2, Hess = TRUE)
ologit_income = polr(anz_teilnahme ~ alter_v + sex_c + konfession_c + residenz10 + zugezogen +
                       steuerb_einkommen_imputed1000k, 
                    data = data_mlogit_h2, Hess = TRUE)
summary(ologit_income)

ologit_wealth= polr(anz_teilnahme ~ alter_v + sex_c + konfession_c + residenz10 + zugezogen +
                      reinvermoegen_imputed1000k, 
                   data = data_mlogit_h2, Hess = TRUE)
summary(ologit_wealth)


ologit_incwealth= polr(anz_teilnahme ~ alter_v + sex_c + konfession_c + residenz10 + zugezogen +
                         steuerb_einkommen_imputed1000k + reinvermoegen_imputed1000k, 
                      data = data_mlogit_h2, Hess = TRUE)
# summary(ologit_incwealth)


library(pscl)

round(pR2(ologit_empty),4)
round(pR2(ologit_income),4)
round(pR2(ologit_wealth),4)
round(pR2(ologit_incwealth),4)
```


```{r message=FALSE, warning=FALSE}

# brant(model_incwealth, by.var = FALSE)
```

Parallel Regression Assumption only holds for predictors age, gender, income and wealth.
-->Since it doesn't hold for all variables, we cannot perform a ordinal logit model.


*Instead I implement a multinomial logit model:*
->It is a bit of information loss when grouping the counts of participation on votes into the voting types, however
it makes the overview and the model much easier to read and interpret. The full model, without aggregation will be
in the appendix.

https://cran.r-project.org/web/packages/MNLpred/readme/README.html

```{r message=FALSE, warning=FALSE}
library(nnet)


data_mlogit_h2 <- data_mlogit %>% 
  mutate(steuerb_einkommen_imputed1000k = steuerb_einkommen_imputed/1000,
         massgebendesEinkommen_imputed1000k = massgebendesEinkommen_imputed/1000,
         reinvermoegen_imputed1000k = reinvermoegen_imputed/1000,
         hhaequEinkommen1000k = hhaequEinkommen/1000,
         hhaequVermoegen1000k = hhaequVermoegen/1000) %>% 
  mutate(age_cat = case_when(
    alter_v <= 35 ~ "18-35-Jährige",
    alter_v > 35 & alter_v <= 50 ~ "35-50-Jährige",
    alter_v > 50 & alter_v <= 65  ~ "50-65-Jährige",
    alter_v > 65 ~ "Über 65-Jährige"
  )) %>% 
  mutate(age_cat_num = case_when(
    alter_v <= 35 ~ 1,
    alter_v > 35 & alter_v <= 50 ~ 2,
    alter_v > 50 & alter_v <= 65  ~ 3,
    alter_v > 65 ~ 4
  ))


mlogit_empty <- multinom(vote_type ~ alter_v + sex_c + konfession_c + residenz10 + zugezogen ,
                       data = data_mlogit_h2)
mlogit_inc <- multinom(vote_type ~ alter_v + sex_c + konfession_c + residenz10 + zugezogen +
                         steuerb_einkommen_imputed1000k,
                       data = data_mlogit_h2)
mlogit_wealth <- multinom(vote_type ~ alter_v + sex_c + konfession_c + residenz10 + zugezogen +
                            reinvermoegen_imputed1000k,
                       data = data_mlogit_h2)
mlogit_incwealth <- multinom(vote_type ~ alter_v + sex_c + konfession_c + residenz10 + zugezogen +
                               steuerb_einkommen_imputed1000k + reinvermoegen_imputed1000k,
                       data = data_mlogit_h2)

stargazer(mlogit_inc, mlogit_wealth, mlogit_incwealth, type = "text")

# summary(mlogit_inc)
# summary(mlogit_wealth)
# summary(mlogit_incwealth)


# Check different goodness-of-fit measures for the models
# install.packages("pscl")
library(pscl)

round(pR2(mlogit_empty),4)
round(pR2(mlogit_inc),4)
round(pR2(mlogit_wealth),4)
round(pR2(mlogit_incwealth),4)
```

#### Predicted Probability for Income and wealth

```{r message=FALSE, warning=FALSE}
# Predicted Probability for Income
# Take quartiles of age for destinction of effects
mlogit_inc2 <- multinom(vote_type ~ age_cat_num + sex_c + konfession_c + residenz10 + 
                          zugezogen + steuerb_einkommen_imputed1000k,
                        data = data_mlogit_h2)
mlogit_wealth2 <- multinom(vote_type ~ age_cat_num + sex_c + konfession_c + residenz10 + 
                             zugezogen + reinvermoegen_imputed1000k,
                           data = data_mlogit_h2)

profile1 <- predicts(mlogit_inc2, "1;mode;mode;mode;mode;0-200,10", position = 6)
profile2 <- predicts(mlogit_inc2, "2;mode;mode;mode;mode;0-200,10", position = 6)
profile3 <- predicts(mlogit_inc2, "3;mode;mode;mode;mode;0-200,10", position = 6)
profile4 <- predicts(mlogit_inc2, "4;mode;mode;mode;mode;0-200,10", position = 6)

profile_income <- profile1 %>% 
  bind_rows(profile2, profile3, profile4) %>% 
  mutate(age_cat = case_when(
    age_cat_num ==1 ~ "18-35-Jährige",
    age_cat_num ==2 ~ "35-50-Jährige",
    age_cat_num ==3 ~ "50-65-Jährige",
    age_cat_num ==4  ~ "Über 65-Jährige"
  )) %>% 
  mutate(level = fct_relevel(level, c("never voter", "selective voter", "always voter")))
rm(profile1, profile2, profile3, profile4)

plot_income <- ggplot(profile_income, aes(x = steuerb_einkommen_imputed1000k_val1, group= age_cat)) +
  geom_line(aes(y = val1_mean, color = age_cat), size = 0.5) + 
  geom_ribbon(aes(y = val1_mean, ymin = val1_lower, ymax = val1_upper, fill = age_cat), alpha = .2) +
  facet_wrap(~ level, ncol = 1) +
  scale_colour_masterthesis() +
  scale_fill_masterthesis() +
  guides(fill="none") +
  theme_masterthesis() +
  labs(title = "Einkommen",
       x = "Einkommen (in 1000 Fr.)", 
       y = "Predicted Probability",
       color = "Altersgruppe")


# Predicted Probabilities for Wealth
profile1 <- predicts(mlogit_wealth2, "1;mode;mode;mode;mode;0-220,10", position = 6)
profile2 <- predicts(mlogit_wealth2, "2;mode;mode;mode;mode;0-220,10", position = 6)
profile3 <- predicts(mlogit_wealth2, "3;mode;mode;mode;mode;0-220,10", position = 6)
profile4 <- predicts(mlogit_wealth2, "4;mode;mode;mode;mode;0-220,10", position = 6)

profile_wealth <- profile1 %>% 
  bind_rows(profile2, profile3, profile4) %>% 
  mutate(age_cat = case_when(
    age_cat_num ==1 ~ "18-35-Jährige",
    age_cat_num ==2 ~ "35-50-Jährige",
    age_cat_num ==3 ~ "50-65-Jährige",
    age_cat_num ==4 ~ "Über 65-Jährige"
  )) %>% 
  mutate(level = fct_relevel(level, c("never voter", "selective voter", "always voter")))
rm(profile1, profile2, profile3, profile4)

   
plot_wealth <- ggplot(profile_wealth, aes(x = reinvermoegen_imputed1000k_val1, group = age_cat)) +
  geom_line(aes(y = val1_mean, color = age_cat), size = 0.5) + 
  geom_ribbon(aes(y = val1_mean, ymin = val1_lower, ymax = val1_upper, fill = age_cat), alpha = .2) +
  facet_wrap(~ level, ncol = 1) +
  scale_colour_masterthesis() +
  scale_fill_masterthesis() +
  guides(fill="none") +
  theme_masterthesis() +
  labs(title = "Vermögen",
       x = "Vermögen (in 1000 Fr.)", 
       y = "Predicted Probability",
       color = "Altersgruppe")


library(ggpubr)
plot_predprob <- ggarrange(plot_income, plot_wealth, ncol=2, common.legend = TRUE, legend="bottom")
plot_predprob

# save Plot 
ggsave("/Users/alinelaurametzler/Documents/Universität/Master/Master Thesis/MA-Code/Output/plot_predprob.png",
       width = 20, height = 20, units = "cm")

```

## H3: Effect of Income by Age

```{r message=FALSE, warning=FALSE}
mlogit_incwealthage <- multinom(vote_type ~ alter_v + sex_c + konfession_c + residenz10 + 
                                  zugezogen + steuerb_einkommen_imputed1000k + steuerb_einkommen_imputed1000k*alter_v +
                                  reinvermoegen_imputed1000k + reinvermoegen_imputed1000k*alter_v,
                       data = data_mlogit_h2)

stargazer(mlogit_inc, mlogit_wealth, mlogit_incwealth, mlogit_incwealthage, type = "text")


# Verändert sich R2??
```


## H4: Effects of Jumps in Income / Wealth

```{r message=FALSE, warning=FALSE}
# der Scatterplot verleitet zur Annahme dass Einkommen einen nicht-linearen Effekt auf die Beteiligung an Abstimmungen hat
scatter_income <- data_mlogit %>% 
  filter(!is.na(steuer_tarif_imputed)) %>% 
  ggplot(aes(x = massgebendesEinkommen_imputed_noweights, y = anz_teilnahme)) +
  facet_wrap(~ steuer_tarif_imputed) +
  geom_jitter(alpha = 0.1) +
  geom_smooth() +
  scale_colour_masterthesis() +
  theme_masterthesis() 
scatter_income


scatter_hhaequEinkommen <- data_mlogit %>% 
  # filter(!is.na(steuer_tarif_imputed)) %>% 
  filter(hhaequEinkommen <= 200000) %>% 
  ggplot(aes(x = hhaequEinkommen, y = anz_teilnahme)) +
  # facet_wrap(~ steuer_tarif_imputed) +
  geom_jitter(alpha = 0.1) +
  geom_smooth() +
  scale_colour_masterthesis() +
  theme_masterthesis() 
scatter_hhaequEinkommen
```

make sure that in the following 1-2 years income doesn't rise again, so we can exclude a short term 
jump in income which could step from a big investment or 

also exclude people that are retired for the analysis of income jumps

```{r message=FALSE, warning=FALSE}
# get aggregated data by year for respondents
data_year <- data %>% 
  mutate(anz_teilnahme = case_when(
    beteiligt == "mit Stimmbeteiligung" ~ 1,
    TRUE ~ 0
  )) %>% 
  mutate(anz_abstimmungen = case_when(
    beteiligt == "mit Stimmbeteiligung" ~ 1,
    beteiligt == "keine Stimmbeteiligung" ~ 1
  )) %>% 
  group_by(id_ek, abstimmungsjahr) %>%
  summarise(anz_teilnahme = sum(anz_teilnahme),
            anz_abstimmungen = sum(anz_abstimmungen),
            share_teilnahme = anz_teilnahme/anz_abstimmungen,
            sex = last(sex_imp),
            alter = mean(alter_v, na.rm=TRUE),
            konfession = last(konfession_imp),
            residenz = mean(residenz_imp, na.rm=TRUE),
            zugezogen = last(zugezogen),
            einkommen = mean(hhaequEinkommen, na.rm=TRUE),
            vermoegen = mean(hhaequVermoegen, na.rm=TRUE)
            ) %>% 
  distinct() %>% 
  ungroup() %>% 
  group_by(id_ek) %>% 
  # calculate change compared to previous year
  mutate(change_eink = round(100 * (einkommen - lag(einkommen))/lag(einkommen))) %>% 
  mutate(change_verm = round(100 * (vermoegen - lag(vermoegen, default = NA))/lag(vermoegen, default = NA))) %>% 
  mutate(change_eink = case_when(
    is.nan(change_eink) & !is.nan(einkommen) ~ 0, # wenn Einkommen gleich bleibt, dann keine Veränderung
    is.infinite(change_eink) ~ einkommen, # wenn Einkommen von 0 auf eine Zahl steigt, dann 10000
    TRUE ~ change_eink
  )) %>% 
  mutate(change_verm = case_when(
    is.nan(change_verm) & !is.nan(vermoegen) ~ 0,
    is.infinite(change_verm) ~ vermoegen,
    TRUE ~ change_verm
  ))

library(rlang)
change_did <- function(change_var, nochange_var, change_quantity, change_quantity_other){
  
  # Identify individuals with bigger changes in income or wealth
  # Change from some income to 0
  data_change <- data_year %>% 
    # Identify big changes in income/wealth
    # TODO: when is change considered to be big? (after 50% change?)
    mutate(ifchange_income = case_when(
     change_eink <= change_quantity & change_verm <= change_quantity_other ~ 1,
      TRUE ~ 0
    )) %>%
    mutate(ifchange_wealth = case_when(
     change_eink <= change_quantity & change_verm <= change_quantity_other & change_verm < last(change_verm) ~ 1,
      TRUE ~ 0
    )) %>%
    mutate(ifchange = !!sym(change_var)) %>% 
    mutate(ifnochange_eink = case_when(
      abs(change_eink) <= 15 ~ 2,
      TRUE ~ 0
    )) %>% 
    mutate(ifnochange_verm= case_when(
      abs(change_verm) <= 15 ~ 2,
      TRUE ~ 0
    )) %>% 
    mutate(ifnochange = !!sym(nochange_var)) %>% 

    # for multiple income/wealth shocks only take first one
    group_by(id_ek) %>%
    mutate(change = as.numeric(rle(ifchange)$lengths %>% {rep(seq(length(.)), .)})) %>% 
    ungroup() %>% 
    mutate(change = case_when(
      change > 2 ~ 3,
      TRUE ~ change
    )) %>% 
    mutate(treatment_year = case_when(
      change == 2 ~ abstimmungsjahr,
      TRUE ~ NA_integer_
    )) %>% 
    group_by(id_ek) %>% 
    fill(treatment_year, .direction = "updown") %>% 
    mutate(treatment = case_when(
      !is.na(treatment_year) ~ 1,
      TRUE ~ 0
    )) %>% 
    # filter people with a stable income for control group (ifchange=0 ->in 5 consecutive rows)
    group_by(id_ek) %>% 
    mutate(cons_stable = {rl <- rle(ifnochange); max(rl$lengths[rl$values == 2])}) %>% 
    filter(treatment == 1 | (treatment == 0 & cons_stable > 5 & ifnochange == 2)) %>% 
    # only consecutive following years
    group_by(id_ek, grp = cumsum(c(1, diff(abstimmungsjahr) != 1))) %>% 
    filter(treatment == 1 | (n() > 5)) %>% 
    
    # create var years from/to treatment. For the never-treated (i.e. control) units,
    # we'll set the "time_to_treatment" value at 0 for the middle year.
    mutate(treatment_year = 
             ifelse(is.na(treatment_year), round(mean(abstimmungsjahr)), treatment_year)) %>% 
    mutate(time_to_treat = (abstimmungsjahr - treatment_year)) %>% 
    # mutate(time_to_treat = ifelse(treatment == 1, (abstimmungsjahr - treatment_year), 0)) %>% 
    
    # there needs to be at least one period before & after income change
    filter(treatment_year > min(abstimmungsjahr) & treatment_year < max(abstimmungsjahr)) %>% 
    # only look at at smaller time span: 3 years before and after shock
    filter(time_to_treat >= -3 & time_to_treat <= 2)
  
  library(fixest) 
  # TODO: do I need to account for all control variables in the diff-in-diff model? 
  # -->how should I handle the categorical ones?
  
  # income shocks
  mod_twfe = feols(share_teilnahme ~ i(time_to_treat, treatment, ref = -1) + ## key interaction: time × treatment status
  		  alter + einkommen |               ## Other controls
  		  id_ek + abstimmungsjahr,                  ## FEs
  		 cluster = ~id_ek,                          ## Clustered SEs
  		 data = data_change)
  
  # install.packages("remotes")
  # remotes::install_github("grantmcdermott/ggiplot")
  library(ggiplot)
  plot_did <- ggiplot(mod_twfe) +
    # geom_rect(aes(xmin = -1, xmax = 0, 
    #           ymin = -Inf, ymax = Inf), alpha = 0.1) + 
    theme_masterthesis() 
  print(plot_did)

}

plot_did_incometo0 <- change_did("ifchange_income", "ifnochange_eink", -100, 25) +
  labs(x = "Years before and after income drop",
       y = "Voter turnout estimate",
       title = "Effect of Change from some Income to 0")
plot_did_incometo0

plot_did_wealthto0 <- change_did("ifchange_wealth", "ifnochange_verm", 25, -100) +
  labs(x = "Years before and after income drop",
       y = "Voter turnout estimate",
       title = "Effect of Change from some Wealth to 0")
plot_did_wealthto0


```


## H5: Effect of parents income on children (Übertragungshypothese)

Compare households with high income/wealth to households with low income wealth

Compare highest earning person of household to other members that have less income/wealth
-->Especially look at adult children that still live with parents


```{r message=FALSE, warning=FALSE}
# Since there is no exact Information on family constellation (only HH ID), I just  
# define youth by their age group (18-25) living with older (parent) age group (35-65)
# Filtering households with more than 1 generation excludes shared flats with big 
# age gaps and couples with big age gaps
# this approach ignores families that are out of the defined age range (which is alright
# since we want to look at the effect on the younger generation anyways)

data_households <- data %>% 
  ungroup() %>% 
  # only households where ID is available
  filter(!is.na(householdID_sw_imp)) %>% 
  # only look at private households (exclude grouped and collective hh)
  filter(haushalttyp_sw_1_imp == 1) %>% 
  # only look at household with more than 1 generation
  filter(generationen_sw_imp %in% c(2, 3, 4)) %>%
  # define age groups for younger and older generation
  mutate(young_pers = case_when(
    alter_v <= 25 ~ 1,
    TRUE ~ 0
  )) %>% 
  mutate(older_pers = case_when(
    alter_v > 35 & alter_v <= 70 ~ 1,
    TRUE ~ 0
  )) %>% 
  group_by(householdID_sw_imp, abstimmungsdatum) %>% 
  # all households (mind. 2 generations) with younger and older generation in them
  mutate(sum_young_pers = sum(young_pers),
         sum_older_pers = sum(older_pers)) %>% 
  filter(sum_young_pers >= 1 & sum_older_pers >= 1) %>% 
  arrange(householdID_sw_imp, id_ek) %>% 
  # use household income / wealth to show affluence of family
  filter(!is.na(hhaequEinkommen)) %>% 
  filter(!is.na(hhaequVermoegen)) %>% 
  # income of older generation alone
  group_by(householdID_sw, abstimmungsdatum, older_pers) %>% 
  mutate(income_older = case_when(
    # married couples have joined incomes
    steuer_tarif_imputed == "verheiratet" & older_pers == 1 ~ 
      sum(steuerb_einkommen_imputed2)/(1 + ((sum(older_pers)-1)*0.5)),
    steuer_tarif_imputed == "alleinstehend/unverheiratet"  & older_pers == 1 ~ 
      sum(steuerb_einkommen_imputed)/(1 + ((sum(older_pers)-1)*0.5)) ,
    older_pers == 0 ~ NA_real_, 
    TRUE ~ NA_real_
  )) %>% 
  mutate(wealth_older = case_when(
    # married couples have joined incomes
    steuer_tarif_imputed == "verheiratet" & older_pers == 1 ~ 
      sum(reinvermoegen_imputed2)/(1 + ((sum(older_pers)-1)*0.5)),
    steuer_tarif_imputed == "alleinstehend/unverheiratet" & older_pers == 1 ~ 
      sum(reinvermoegen_imputed) /(1 + ((sum(older_pers)-1)*0.5)),
    older_pers == 0 ~ NA_real_, 
    TRUE ~ NA_real_
  )) %>% 
  ungroup() %>% 
  group_by(householdID_sw_imp, abstimmungsdatum) %>% 
  fill(wealth_older, .direction = "updown") %>%
  fill(income_older, .direction = "updown") %>%
  ungroup() %>% 
  mutate(inc_quantile25 = quantile(income_older, 0.25, na.rm = TRUE),
         inc_quantile50 = quantile(income_older, 0.5, na.rm = TRUE),
         inc_quantile75 = quantile(income_older, 0.75, na.rm = TRUE),
         wea_quantile25 = quantile(wealth_older, 0.25, na.rm = TRUE),
         wea_quantile50 = quantile(wealth_older, 0.5, na.rm = TRUE),
         wea_quantile75 = quantile(wealth_older, 0.75, na.rm = TRUE)) %>% 
  # parents income quantile as control
  mutate(income_older_quantile = case_when(
    is.na(income_older) ~ NA_character_,
    income_older <= inc_quantile25 ~ "1. Quartil",
    income_older > inc_quantile25 & income_older <= inc_quantile50 ~ "2. Quartil",
    income_older > inc_quantile50 & income_older <= inc_quantile75 ~ "3. Quartil",
    income_older > inc_quantile75 ~ "4. Quartil",
    TRUE ~ NA_character_
  )) %>% 
  # parents wealth quantile as control
  mutate(wealth_older_quantile = case_when(
    is.na(wealth_older) ~ NA_character_,
    wealth_older <= wea_quantile25 ~ "1. Quartil",
    wealth_older > wea_quantile25 & wealth_older <= wea_quantile50 ~ "2. Quartil",
    wealth_older > wea_quantile50 & wealth_older <= wea_quantile75 ~ "3. Quartil",
    wealth_older > wea_quantile75 ~ "4. Quartil",
    TRUE ~ NA_character_
  )) %>% 
  select(-inc_quantile25, -inc_quantile50, -inc_quantile75, -wea_quantile25, -wea_quantile50, -wea_quantile75) %>% 
  # parents voting behavior as second IV
  mutate(beteiligt_num = case_when(
    beteiligt == "mit Stimmbeteiligung" ~ 1,
    beteiligt == "keine Stimmbeteiligung" ~ 0,
    TRUE ~ NA_real_
  )) %>% 
  group_by(householdID_sw_imp, abstimmungsdatum, older_pers) %>% 
  mutate(sum_older_pers_vote = case_when(
    older_pers == 1 & beteiligt_num == 1 ~ sum(beteiligt_num),
    older_pers == 1 & beteiligt_num == 0 ~ sum(beteiligt_num),
    older_pers == 0 ~ NA_real_,
    TRUE ~ NA_real_
  )) %>% 
  ungroup() %>% 
  group_by(householdID_sw_imp, abstimmungsdatum) %>% 
  fill(sum_older_pers_vote, .direction = "updown") %>% 
  mutate(ant_older_per_vote = sum_older_pers_vote / sum_older_pers) %>% 
  mutate(older_pers_vote = case_when(
    ant_older_per_vote >= 0.99 ~ "Alle Eltern partizipieren",
    ant_older_per_vote >= 0.01 & ant_older_per_vote < 0.99 ~ "Teils der Eltern partizipieren",
    ant_older_per_vote <= 0.01 ~ "Keine Eltern partizipieren",
    TRUE ~ NA_character_
  )) %>%
  select(-sum_older_pers_vote)
  
# only keep younger gen and take one random vote date per individual
data_households_young <- data_households %>% 
  filter(young_pers == 1) %>% 
  ungroup() %>%
  group_by(id_ek) %>%
  # take one random vote per Individual
  sample_n(1)


# households with low income of parents
data_households_low <- data_households %>% 
  ungroup() %>% 
  filter(quantile(income_older, 0.25) >= income_older) 

mlogit_household_low <- multinom(beteiligt ~  alter_c + sex_c + konfession_c + residenz10 + zugezogen + income_older+ mEinkommen_c + Vermoegen_c,
                   data = data_households_low)



# households with high income of parents
data_households_high <- data_households %>% 
  filter(quantile(income_older, 0.75) <= income_older) 

mlogit_household_high <- multinom(beteiligt ~  alter_c + sex_c + konfession_c + residenz10 + zugezogen + income_older + mEinkommen_c + Vermoegen_c,
                   data = data_households_high)

stargazer(mlogit_household_low, mlogit_household_high, type = "text")

```


## H6: Empfundene Relevanz, Komplexität und Aufmerksamkeit der Abstimmung

```{r message=FALSE, warning=FALSE}



```

## Robustness

-->Auf Multikollinearität prüfen

Alle Analysen mit HHEink, HHVerm und zeigen dass keine Veränderungen

Alle Analysen mit Kateg. Einkommen/Alter etc..

Analyse mit imputations dummies

## Anhang


Alle Analysen mit HHEink, HHVerm und zeigen dass keine Veränderungen

Alle Analysen mit Kateg. Einkommen/Alter etc..

### Scatter Plot Einkommen und Anz. Teilnahmen bei 10 Abstimmungen

H1A/B

```{r message=FALSE, warning=FALSE}
summary(data_mlogit$massgebendesEinkommen_imputed)
summary(data_mlogit$anz_teilnahme)


plot_scatter <- data_mlogit %>% 
  mutate(massgebendesEinkommen_imputed = case_when(
    massgebendesEinkommen_imputed < 0 ~ 0,
    TRUE ~ massgebendesEinkommen_imputed
  )) %>% 
  ggplot(aes(x = massgebendesEinkommen_imputed, y = anz_teilnahme)) +
  # geom_bin2d(bins = 10)
  geom_jitter(alpha = 0.1) +
  geom_smooth() +
  theme_minimal()
plot_scatter

plot_scatter_age <- data_mlogit %>% 
  filter(!is.na(alter_c)) %>% 
  mutate(massgebendesEinkommen_imputed = case_when(
    massgebendesEinkommen_imputed < 0 ~ 0,
    TRUE ~ massgebendesEinkommen_imputed
  )) %>% 
  ggplot(aes(x = massgebendesEinkommen_imputed, y = anz_teilnahme)) +
  geom_jitter(alpha = 0.1) +
  geom_smooth() +
  facet_wrap(~ alter_c) +
  theme_minimal()
plot_scatter_age

plot_scatter_sex <- data_mlogit %>% 
  filter(!is.na(sex_c)) %>% 
  mutate(massgebendesEinkommen_imputed = case_when(
    massgebendesEinkommen_imputed < 0 ~ 0,
    TRUE ~ massgebendesEinkommen_imputed
  )) %>% 
  ggplot(aes(x = massgebendesEinkommen_imputed, y = anz_teilnahme)) +
  geom_jitter(alpha = 0.1) +
  geom_smooth() +
  facet_wrap(~ sex_c) +
  theme_minimal()
plot_scatter_sex


```

### Multinomial Logit Model
Was ist der Unterschied zwischen mlogit() und multinom()? Weshalb funktioniert mlogit() nicht und multinom() schon?

H1.1A/B

```{r message=FALSE, warning=FALSE}
# library(mlogit)
#
# # Generating the Person-Choice Matrix
# data_mlogitprep <- as.data.frame(data_mlogit) %>% 
#   select(vote_type, alter_c, sex_c, konfession_c, residenz10, zugezogen, mEinkommen_c, Vermoegen_c) %>% 
#   na.omit()
# data_mlogit.pc <- mlogit.data(data_mlogitprep,
#                               varying = 2:8,
#                               choice = "vote_type",
#                               shape = "wide",
#                               sep = "_")
# head(data_mlogit.pc)
# 
# mlogit.fit <- mlogit(vote_type ~ 0 | alter_c + sex_c + konfession_c + residenz10 + zugezogen + mEinkommen_c + Vermoegen_c,
#                           shape = "long",
#                           data = data_mlogit.pc)

library(nnet)
library(stargazer)
mlogit <- multinom(vote_type ~ alter_c + sex_c + konfession_c + residenz10 + zugezogen + mEinkommen_c + Vermoegen_c,
                   data = data_mlogit)
stargazer(mlogit, type = "text")
```


```{r message=FALSE, warning=FALSE}
mlogit_det <- multinom(vote_type_det ~ alter_c + sex_c + konfession_c + residenz10 + zugezogen + mEinkommen_c + Vermoegen_c,
                   data = data_mlogit15)
stargazer(mlogit_det, type = "text")
```

### Effect of age on political participation for different income quartiles

H2

```{r message=FALSE, warning=FALSE}
plot_scatter_ageincome <- data_mlogit %>% 
  filter(!is.na(mEinkommen_c)) %>% 
  mutate(massgebendesEinkommen_imputed = case_when(
    massgebendesEinkommen_imputed < 0 ~ 0,
    TRUE ~ massgebendesEinkommen_imputed
  )) %>% 
  ggplot(aes(x = alter_v, y = anz_teilnahme)) +
  geom_jitter(alpha = 0.1) +
  geom_smooth() +
  facet_wrap(~ mEinkommen_c) +
  theme_minimal()
plot_scatter_ageincome


plot_scatter_agevermoegen <- data_mlogit %>% 
  filter(!is.na(mEinkommen_c)) %>% 
  mutate(massgebendesEinkommen_imputed = case_when(
    massgebendesEinkommen_imputed < 0 ~ 0,
    TRUE ~ massgebendesEinkommen_imputed
  )) %>% 
  ggplot(aes(x = alter_v, y = anz_teilnahme)) +
  # geom_point() +
  # geom_jitter() +
  geom_smooth() +
  facet_wrap(~ Vermoegen_c) +
  theme_minimal()
plot_scatter_agevermoegen


plot_scatter_age
```

### Effect of jumps in income/wealth

H3A/B

Identify the jumps

->Since we only have income per year -->participation as share (sum(partic)/sum(all_votes))
-->then look for jumps in yearly income
-->compare share of participation before and after


Possible distinctions:
1)	From no income to some income
2)	From some income to no income
3)	From some income to less than 50% of that income
4)	From some income to less than 75% of that income

TODO: Do you have a recommendation for defining jumps of income/wealth? And should I address it seperately in the paper?

```{r message=FALSE, warning=FALSE}
library(data.table) 

# TODO: write function to just specify income/wealth and the wanted distinction of jumps

# get aggregated data by year for respondents
data_year <- data %>% 
  mutate(anz_teilnahme = case_when(
    beteiligt == "mit Stimmbeteiligung" ~ 1,
    TRUE ~ 0
  )) %>% 
  mutate(anz_abstimmungen = case_when(
    beteiligt == "mit Stimmbeteiligung" ~ 1,
    beteiligt == "keine Stimmbeteiligung" ~ 1
  )) %>% 
  group_by(id_ek, abstimmungsjahr) %>%
  summarise(anz_teilnahme = sum(anz_teilnahme),
            anz_abstimmungen = sum(anz_abstimmungen),
            share_teilnahme = anz_teilnahme/anz_abstimmungen,
            sex = last(sex_imp),
            alter = mean(alter_v, na.rm=TRUE),
            konfession = last(konfession_imp),
            residenz = mean(residenz_imp, na.rm=TRUE),
            zugezogen = last(zugezogen),
            einkommen = mean(hhaequEinkommen, na.rm=TRUE),
            vermoegen = mean(hhaequVermoegen, na.rm=TRUE)
            ) %>% 
  distinct() %>% 
  ungroup() 

# Identify individuals with bigger changes in income or wealth
data_year <- data_year %>% 
  group_by(id_ek) %>% 
  # calculate change compared to previous year
  mutate(change_eink = 100 * (einkommen - lag(einkommen, default = NA))/lag(einkommen, default = NA)) %>% 
  mutate(change_verm = 100 * (vermoegen - lag(vermoegen, default = NA))/lag(vermoegen, default = NA)) %>% 
  # Identify big changes in income/wealth
  # TODO: when is change considered to be big? (after 50% change?)
  mutate(bigchange_eink50 = case_when(
    change_eink >= 20 ~ 5,
    change_eink >= 50 ~ 1,
    change_eink <= -50 ~ 2,
    TRUE ~ 0
  )) %>% 
  mutate(bigchange_verm50 = case_when(
    change_verm >= 20 ~ 5,
    change_verm >= 50 ~ 1,
    change_verm <= -50 ~ 2,
    TRUE ~ 0
  )) %>% 
  mutate(bigchange_eink75 = case_when(
    change_eink >= 20 ~ 5,
    change_eink >= 50 ~ 1,
    change_eink <= -75 ~ 3,
    TRUE ~ 0
  )) %>% 
  mutate(bigchange_verm75 = case_when(
    change_verm >= 20 ~ 5,
    change_verm >= 50 ~ 1,
    change_verm <= -75 ~ 3,
    TRUE ~ 0
  )) %>% 
  # create variable to detect individuals with treatment (i.e. big income drop)
  # Only valid when also wealth dropped (otherwise just income shift)
  mutate(treat_less50income = case_when(
    bigchange_eink50 == 2 & bigchange_verm50 %in% c(0, 5) ~ 1,
    TRUE ~ 0
  )) %>% 
  mutate(treat_less50wealth = case_when(
    bigchange_verm50 == 2 & bigchange_eink50 %in% c(0, 5) ~ 1,
    TRUE ~ 0
  )) %>% 
  mutate(treat_less75income = case_when(
    bigchange_eink75 == 3 & bigchange_verm75 %in% c(0, 5) ~ 1,
    TRUE ~ 0
  )) %>% 
  mutate(treat_less75wealth = case_when(
    bigchange_verm75 == 3 & bigchange_eink75 %in% c(0, 5) ~ 1,
    TRUE ~ 0
  )) 


data_year <- data_year %>%
  # for multiple income/wealth shocks only take first one
  group_by(id_ek) %>%
  mutate(inc_change50 = as.numeric(rle(treat_less50income)$lengths %>% {rep(seq(length(.)), .)})) %>% 
  mutate(wealth_change50 = as.numeric(rle(treat_less50wealth)$lengths %>% {rep(seq(length(.)), .)})) %>% 
  mutate(inc_change75 = as.numeric(rle(treat_less75income)$lengths %>% {rep(seq(length(.)), .)})) %>% 
  mutate(wealth_change75 = as.numeric(rle(treat_less75wealth)$lengths %>% {rep(seq(length(.)), .)})) %>%
  ungroup() %>% 
  mutate(inc_change50 = case_when(
    inc_change50 > 2 ~ 3,
    TRUE ~ inc_change50
  )) %>% 
  mutate(wealth_change50 = case_when(
    wealth_change50 > 2 ~ 3,
    TRUE ~ wealth_change50
  )) %>% 
  mutate(treatment_year_inc50 = case_when(
    inc_change50 == 2 ~ abstimmungsjahr,
    TRUE ~ NA_integer_
  )) %>% 
  mutate(treatment_year_wealth50 = case_when(
    wealth_change50 == 2 ~ abstimmungsjahr,
    TRUE ~ NA_integer_
  )) %>% 
  mutate(inc_change75 = case_when(
    inc_change75 > 3 ~ 3,
    TRUE ~ inc_change75
  )) %>% 
  mutate(wealth_change75 = case_when(
    wealth_change75 > 3 ~ 3,
    TRUE ~ wealth_change75
  )) %>% 
  mutate(treatment_year_inc75 = case_when(
    inc_change75 == 3 ~ abstimmungsjahr,
    TRUE ~ NA_integer_
  )) %>% 
  mutate(treatment_year_wealth75 = case_when(
    wealth_change75 == 3 ~ abstimmungsjahr,
    TRUE ~ NA_integer_
  )) %>% 
  group_by(id_ek) %>% 
  fill(treatment_year_inc50, .direction = "updown") %>% 
  fill(treatment_year_wealth50, .direction = "updown") %>% 
  fill(treatment_year_inc75, .direction = "updown") %>% 
  fill(treatment_year_wealth75, .direction = "updown") %>% 
  mutate(treat_less50income = case_when(
    !is.na(treatment_year_inc50) ~ 1,
    TRUE ~ 0
  )) %>% 
  mutate(treat_less50wealth = case_when(
    !is.na(treatment_year_wealth50) ~ 1,
    TRUE ~ 0
  )) %>% 
  mutate(treat_less75income = case_when(
    !is.na(treatment_year_inc75) ~ 1,
    TRUE ~ 0
  )) %>% 
  mutate(treat_less75wealth = case_when(
    !is.na(treatment_year_wealth75) ~ 1,
    TRUE ~ 0
  )) %>% 
  # create var years from/to treatment. For the never-treated (i.e. control) units,
  # we'll set the "time_to_treatment" value at 0 for the middle year.
  mutate(treatment_year_inc50 = 
           ifelse(is.na(treatment_year_inc50), round(mean(abstimmungsjahr)), treatment_year_inc50)) %>% 
  mutate(treatment_year_wealth50 = 
           ifelse(is.na(treatment_year_wealth50), round(mean(abstimmungsjahr)), treatment_year_wealth50)) %>% 
  mutate(time_to_treat_inc50 = ifelse(treat_less50income == 1, (abstimmungsjahr - treatment_year_inc50), 0)) %>% 
  mutate(time_to_treat_wealth50 = ifelse(treat_less50wealth == 1, (abstimmungsjahr - treatment_year_wealth50), 0)) %>% 
  mutate(treatment_year_inc75 = 
           ifelse(is.na(treatment_year_inc75), round(mean(abstimmungsjahr)), treatment_year_inc75)) %>% 
  mutate(treatment_year_wealth75 = 
           ifelse(is.na(treatment_year_wealth75), round(mean(abstimmungsjahr)), treatment_year_wealth75)) %>% 
  mutate(time_to_treat_inc75 = ifelse(treat_less75income == 1, (abstimmungsjahr - treatment_year_inc75), 0)) %>% 
  mutate(time_to_treat_wealth75 = ifelse(treat_less75wealth == 1, (abstimmungsjahr - treatment_year_wealth75), 0))
  

```


### Difference-in-Differences Event Study 
Help: https://lost-stats.github.io/Model_Estimation/Research_Design/event_study.html



```{r message=FALSE, warning=FALSE}
library(fixest) 
# TODO: do I need to account for all control variables in the diff-in-diff model? 
# -->how should I handle the categorical ones?

# income shocks
mod_twfe = feols(share_teilnahme ~ i(time_to_treat_inc50, treat_less50income, ref = -1) + ## key interaction: time × treatment status
		  alter + einkommen |               ## Other controls
		  id_ek + abstimmungsjahr,                  ## FEs
		 cluster = ~id_ek,                          ## Clustered SEs
		 data = data_year)


iplot(mod_twfe, 
      xlab = 'Time to treatment',
      main = 'Event-Study of the Effects of Neg. Income Shocks on Voter Turnout (TWFE)')


# wealth shocks
mod_twfe2 = feols(share_teilnahme ~ i(time_to_treat_wealth50, treat_less50income, ref = -1) + ## key interaction: time × treatment status
		  alter + vermoegen |               ## Other controls
		  id_ek + abstimmungsjahr,                  ## FEs
		 cluster = ~id_ek,                          ## Clustered SEs
		 data = data_year)


iplot(mod_twfe2, 
      xlab = 'Time to treatment',
      main = 'Event-Study of the Effects of Neg. Wealth Shocks on Voter Turnout (TWFE)')


# income shocks
mod_twfe = feols(share_teilnahme ~ i(time_to_treat_inc75, treat_less75income, ref = -1) + ## key interaction: time × treatment status
		  alter + einkommen |               ## Other controls
		  id_ek + abstimmungsjahr,                  ## FEs
		 cluster = ~id_ek,                          ## Clustered SEs
		 data = data_year)


iplot(mod_twfe, 
      xlab = 'Time to treatment',
      main = 'Event-Study of the Effects of Neg. Income (-75%) Shocks on Voter Turnout (TWFE)')


# wealth shocks
mod_twfe2 = feols(share_teilnahme ~ i(time_to_treat_wealth75, treat_less75income, ref = -1) + ## key interaction: time × treatment status
		  alter + vermoegen |               ## Other controls
		  id_ek + abstimmungsjahr,                  ## FEs
		 cluster = ~id_ek,                          ## Clustered SEs
		 data = data_year)


iplot(mod_twfe2, 
      xlab = 'Time to treatment',
      main = 'Event-Study of the Effects of Neg. Wealth (-75%) Shocks on Voter Turnout (TWFE)')
```



The effect of income is very different depending on the age category!




```{r message=FALSE, warning=FALSE}
plot_scatter_sex
```


### Je geringer die empfundene Relevanz einer Abstimmung ist, desto groesser ist die Rolle, welche das Einkommen bei der Beteiligung am Urnengang spielt. 

TODO: Is there a better method to compare the effect of the independent on the dependent variable than just subsetting the group and looking at the estimates?

```{r message=FALSE, warning=FALSE}
votes <- read.csv("/Users/alinelaurametzler/Documents/Universität/Master/Master Thesis/MA-Code/Data/PreparedData/votes_data_short.csv", encoding = "UTF-8")

# select votes with low/high importance (i.e. lowest/highest quartile of importance)
votes_lowimp <- votes %>% 
  filter(quantile(importance, 0.25) >= importance) %>% 
  select(datum, titel_kurz_d, jour, mois, annee, importance)
votes_highimp <- votes %>% 
  filter(quantile(importance, 0.75) <= importance) %>% 
  select(datum, titel_kurz_d, jour, mois, annee, importance)

# join with admin. data
turnout_lowimp <- votes_lowimp %>% 
  left_join(data, by = "datum")
turnout_highimp <- votes_highimp %>% 
  left_join(data, by = "datum")


# multinomial logit model
mlogit_lowimp <- multinom(beteiligt ~ alter_c + sex_c + konfession_c + residenz10 + zugezogen + mEinkommen_c + Vermoegen_c,
                   data = turnout_lowimp)
mlogit_highimp <- multinom(beteiligt ~ alter_c + sex_c + konfession_c + residenz10 + zugezogen + mEinkommen_c + Vermoegen_c,
                   data = turnout_highimp)

stargazer(mlogit_lowimp, mlogit_highimp, type = "text")
```

### Bei Abstimmungen mit einem grösseren Umverteilungsaspekt spielt das Einkommen eine grössere Rolle bei der Beteiligung am Urnengang.


```{r message=FALSE, warning=FALSE}


# 10.2	Sozialversicherungen
# 6.1	Steuerwesen

votes_umverteilung <- votes %>% 
  filter(d1e2 %in% c(6.1, 10.2))

votes_steuern <- votes %>% 
  filter(d1e2 == 6.1)


# join with admin. data
turnout_umverteilung<- votes_umverteilung %>% 
  left_join(data, by = "datum")
turnout_steuern <- votes_steuern %>% 
  left_join(data, by = "datum")


# multinomial logit model
mlogit_umverteilung <- multinom(beteiligt ~ alter_c + sex_c + konfession_c + residenz10 + zugezogen + mEinkommen_c + Vermoegen_c,
                   data = turnout_umverteilung)
mlogit_steuern <- multinom(beteiligt ~ alter_c + sex_c + konfession_c + residenz10 + zugezogen + mEinkommen_c + Vermoegen_c,
                   data = turnout_steuern)

stargazer(mlogit_umverteilung, mlogit_steuern, type = "text")
```

### Der Effekt von hohem Einkommen überträgt sich auch auf die Beteiligung am Urnengang anderer Personen, welche im selben Haushalt leben.


Compare households with high income/wealth to households with low income wealth

Compare highest earning person of household to other members that have less income/wealth
-->Especially look at adult children that still live with parents


```{r message=FALSE, warning=FALSE}
# TODO: can I just  define children by their age group (18-25) living with older age group (35-65)?
# -->what about couples, shared flats with bigger age gaps? (right now I just ignore this)
data_households <- data %>% 
  ungroup() %>% 
  filter(haushalttyp_sw_2 == "Mehrpersonenhaushalte") %>% 
  filter(generationen_sw %in% c("Zwei Generationen", "Drei Generationen", "Vier Generationen")) %>% 
  mutate(young_pers = case_when(
    alter_v <= 25 ~ 1,
    TRUE ~ 0
  )) %>% 
  mutate(older_pers = case_when(
    alter_v > 35 & alter_v <= 65 ~ 1,
    TRUE ~ 0
  )) %>% 
  group_by(householdID_sw) %>% 
  # all housholds (mind. 2 generations) with young people and older people in them
  filter(sum(young_pers) >= 1 & sum(older_pers) >= 1) %>% 
  # create variable to sum income of parents (=older_pers in household)
  group_by(householdID_sw, older_pers) %>% 
  mutate(income_older = case_when(
    # married couples have joined incomes
    steuer_tarif_imputed == "verheiratet" & older_pers == 1 ~ massgebendesEinkommen_imputed,
    steuer_tarif_imputed == "alleinstehend/unverheiratet" & older_pers == 1 ~ sum(massgebendesEinkommen_imputed) ,
    TRUE ~ NA_real_
  )) %>% 
  ungroup() %>% 
  group_by(householdID_sw) %>% 
  fill(income_older, .direction = "updown") %>% 
  filter(young_pers == 1) %>% 
  ungroup() %>% 
  filter(!is.na(income_older)) %>% 
  # take one random vote date per individual
  group_by(id_ek) %>%
  sample_n(1)


# households with low income of parents
data_households_low <- data_households %>% 
  ungroup() %>% 
  filter(quantile(income_older, 0.25) >= income_older) 

mlogit_household_low <- multinom(beteiligt ~  alter_c + sex_c + konfession_c + residenz10 + zugezogen + income_older+ mEinkommen_c + Vermoegen_c,
                   data = data_households_low)



# households with high income of parents
data_households_high <- data_households %>% 
  filter(quantile(income_older, 0.75) <= income_older) 

mlogit_household_high <- multinom(beteiligt ~  alter_c + sex_c + konfession_c + residenz10 + zugezogen + income_older + mEinkommen_c + Vermoegen_c,
                   data = data_households_high)

stargazer(mlogit_household_low, mlogit_household_high, type = "text")

```



